# -*- coding: utf-8 -*-
"""two_random_variables.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NAoNrGso5sWju0tmGIxY5n3shWofcHXt
"""

import numpy as np
import math
from math import pi
import matplotlib.pyplot as plt
from sympy import Matrix, sqrt

N = 1000 #number of sample points per random variable(component of the random vector)
K = 2 #number of random variables per random process(number of components)
rho = 0.9 #correlation coefficient

def box_muller(arr1, arr2):
    arr1 = np.clip(arr1, 1e-15, 1-1e-15)
    arr2 = np.clip(arr2, 1e-15, 1-1e-15)
    z1 = np.sqrt(-2 * np.log(arr1)) * np.cos(2 * pi * arr2)
    z2 = np.sqrt(-2 * np.log(arr1)) * np.sin(2 * pi * arr2)
    return z1, z2

#generation of two random gaussian random vectors
random_array1 = np.random.uniform(0, 1, N)
random_array2 = np.random.uniform(0, 1, N)
boxarr1, boxarr2 = box_muller(random_array1, random_array2)

#generation of the two correlated random variables with correlation coefficient rho
vec1 = boxarr1
vec2 = rho*boxarr1 + math.sqrt(1-rho*rho)*boxarr2
plt.scatter(vec1, vec2, color = 'black', s= 1)

#generating the vector Y with K random variables each with N sample points
Y1, Y2 = box_muller(random_array1, random_array2)
Y = np.array([Y1, Y2])

covar_matrix = np.mat([[1, rho], [rho, 1]])
eigenvalues, _ = np.linalg.eig(covar_matrix)

cov_mat = Matrix([[1,rho], [rho, 1]])
P, D = cov_mat.diagonalize()
P = np.mat(P).astype('float')
D = np.mat(D).astype('float')
D = np.sqrt(D)
PT = P.T
eigenvalrt = np.sqrt(eigenvalues)

output = P @ D

vec1 = output[0,0] * Y1 + output[0,1] * Y2
vec2 = output[1,0] * Y1 + output[1,1] * Y2
plt.scatter(vec1, vec2, s = 1)
plt.show()
