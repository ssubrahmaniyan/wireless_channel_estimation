% Main script for comparing all approaches
clear all;
close all;

% Common Parameters
EbNo_dB = -1:0.5:10;
N = 1000000;  % Total channel samples
max_frames = 100;
data_bits = 51;  % Number of uncoded bits to send each time
code_rate = 1/2;
coded_bits = data_bits/code_rate;   % LDPC codeword length

% Load Jakes channel
channel_values = complex(zeros(N, 1));
fid = fopen('channels.txt', 'r');
for i = 1:N
    line = fgetl(fid);
    if ischar(line)
        values = jsondecode(line);
        channel_values(i) = complex(values(1), values(2));
    end
end
fclose(fid);

% LDPC code parameters
n = 102;  % codeword length
k = 51;   % message length
code_rate = k/n;

% Create parity check matrix using sparse random matrix with identity
m = n - k;  % number of parity checks
H = logical(sparse([randi([0,1], m, k) eye(m)]));

% Create LDPC encoder and decoder configuration objects
encodercfg = ldpcEncoderConfig(H);
decodercfg = ldpcDecoderConfig(H);

% Initialize arrays for all scenarios
BER_standard_jakes = zeros(size(EbNo_dB));
BER_ldpc_jakes = zeros(size(EbNo_dB));
BER_ar_uncoded = zeros(size(EbNo_dB));
BER_ar_coded = zeros(size(EbNo_dB));
retrans_freq_uncoded = zeros(size(EbNo_dB));
retrans_freq_coded = zeros(size(EbNo_dB));

% AR model parameters
var_order = 25;
pilot_size = 50;
mse_threshold = 0.1;
initial_pilots = 2*var_order + 2;

% Main simulation loop
for i = 1:length(EbNo_dB)
    fprintf('Simulating Eb/No = %.1f dB\n', EbNo_dB(i));
    
    % Convert Eb/No to SNR
    snr_db = EbNo_dB(i) + 10*log10(code_rate);
    SNR = 10^(snr_db/10);
    noise_var = 1/(2*SNR);
    
    % Variables for counting
    errors_standard = 0;
    total_bits_standard = 0;
    errors_ldpc = 0;
    total_bits_ldpc = 0;
    
    % Standard Jakes simulation
    current_idx = 1;
    for frame = 1:max_frames
        % Standard (uncoded) transmission
        info_bits = randi([0 1], data_bits, 1);
        symbols = 1 - 2*info_bits;
        channel = channel_values(current_idx:current_idx+data_bits-1);
        snr_db_uncoded = EbNo_dB(i);  % For uncoded case, rate = 1
        SNR_uncoded = 10^(snr_db_uncoded/10);
        noise = sqrt(1/2) * (randn(data_bits,1) + 1j*randn(data_bits,1)) / sqrt(SNR_uncoded);
        received = channel.*symbols + noise;
        decisions = real(received./channel) < 0;
        errors_standard = errors_standard + sum(decisions ~= info_bits);
        total_bits_standard = total_bits_standard + data_bits;
        
        % LDPC coded Jakes
        info_bits_ldpc = randi([0 1], data_bits, 1);
        % Use LDPC encoder with encoder config
        coded_bits_ldpc = ldpcEncode(info_bits_ldpc, encodercfg);
        symbols_ldpc = 1 - 2*coded_bits_ldpc;
        channel_ldpc = channel_values(current_idx:current_idx+n-1);
        snr_db_coded = EbNo_dB(i) + 10*log10(code_rate);
        SNR_coded = 10^(snr_db_coded/10);
        noise_ldpc = sqrt(1/2) * (randn(n,1) + 1j*randn(n,1)) / sqrt(SNR_coded);
        received_ldpc = channel_ldpc.*symbols_ldpc + noise_ldpc;
        
        % LDPC decoding
        llr = 2*real(conj(channel_ldpc).*received_ldpc)./(abs(channel_ldpc).^2 * noise_var);
        decoded_bits = ldpcDecode(llr, decodercfg, 50);  % 50 iterations max
        errors_ldpc = errors_ldpc + sum(decoded_bits(1:data_bits) ~= info_bits_ldpc);
        total_bits_ldpc = total_bits_ldpc + data_bits;
        
        current_idx = current_idx + n;
    end
    
    % Store BER for Jakes simulations
    BER_standard_jakes(i) = errors_standard/total_bits_standard;
    BER_ldpc_jakes(i) = errors_ldpc/total_bits_ldpc;
    
    % AR Model Simulations
    [retrans_freq_uncoded(i), BER_ar_uncoded(i)] = simulateAR(channel_values, ...
        false, data_bits, var_order, pilot_size, mse_threshold, initial_pilots, EbNo_dB(i), H, n);
    
    [retrans_freq_coded(i), BER_ar_coded(i)] = simulateAR(channel_values, ...
        true, data_bits, var_order, pilot_size, mse_threshold, initial_pilots, EbNo_dB(i), H, n);
end

% Plotting
figure(1);
semilogy(EbNo_dB, BER_standard_jakes, 'k-o', 'DisplayName', 'Standard Jakes');
hold on;
semilogy(EbNo_dB, BER_ldpc_jakes, 'b-s', 'DisplayName', 'LDPC Jakes');
semilogy(EbNo_dB, BER_ar_uncoded, 'r-^', 'DisplayName', 'AR Uncoded');
semilogy(EbNo_dB, BER_ar_coded, 'm-v', 'DisplayName', 'AR Coded');
grid on;
xlabel('E_b/N_0 (dB)');
ylabel('Bit Error Rate (BER)');
title('BER Performance Comparison');
legend('Location', 'southwest');

figure(2);
plot(EbNo_dB, retrans_freq_uncoded, 'r-o', 'DisplayName', 'AR Uncoded');
hold on;
plot(EbNo_dB, retrans_freq_coded, 'b-s', 'DisplayName', 'AR Coded');
grid on;
xlabel('E_b/N_0 (dB)');
ylabel('Retransmission Frequency');
title('Pilot Retransmission Frequency');
legend('Location', 'northeast');

% Helper function for AR simulation
function [retrans_freq, ber] = simulateAR(channel_values, use_coding, data_bits, ...
    var_order, pilot_size, mse_threshold, initial_pilots, EbNo_dB, H, n)
    
    % Create encoder and decoder config
    encodercfg = ldpcEncoderConfig(H);
    decodercfg = ldpcDecoderConfig(H);
    
    % Initialize variables
    current_idx = 1;
    total_bits = 0;
    wrong_bits = 0;
    pilot_requests = 0;
    code_rate = 1/2;
    
    % Initial transmission: 2*var_order + 2 bits
    initial_bits = 2*var_order + 2;
    
    % Transmit initial bits and get channel estimates
    info_bits = randi([0 1], initial_bits, 1);
    symbols = 1 - 2*info_bits;
    actual_channel = channel_values(current_idx:current_idx+initial_bits-1);
    
    % Add noise based on SNR
    snr_db = EbNo_dB;
    SNR = 10^(snr_db/10);
    noise = sqrt(1/2) * (randn(initial_bits,1) + 1j*randn(initial_bits,1)) / sqrt(SNR);
    received = actual_channel.*symbols + noise;
    
    % Initial channel estimation using least squares
    channel_estimates = received./(1-2*info_bits);  % Least squares estimation
    current_idx = current_idx + initial_bits;
    pilot_requests = pilot_requests + 1;
    
    % First determine the block size
    if use_coding
        next_block_size = n;
    else
        next_block_size = data_bits;
    end
    
    % Main simulation loop
    while total_bits < 1000000 && current_idx + next_block_size <= length(channel_values)
        % Prepare data for VAR model
        channel_data = [real(channel_estimates), imag(channel_estimates)];
        
        % Create and estimate VAR model
        mdl = varm(2, var_order);
        try
            mdl = estimate(mdl, channel_data);
        catch
            break;
        end
        
        if use_coding
            % LDPC coded transmission
            info_bits = randi([0 1], data_bits, 1);
            coded_bits = ldpcEncode(info_bits, encodercfg);
            symbols = 1 - 2*coded_bits;
            
            % Transmit through channel
            actual_channel = channel_values(current_idx:current_idx+n-1);
            snr_db = EbNo_dB + 10*log10(code_rate);
            SNR = 10^(snr_db/10);
            noise = sqrt(1/2) * (randn(n,1) + 1j*randn(n,1)) / sqrt(SNR);
            received = actual_channel.*symbols + noise;
            
            % Predict n channel values
            [Y, ~] = forecast(mdl, n, channel_data);
            htilde = complex(Y(:,1), Y(:,2));
            
            % Decode using predicted channel
            llr = 2*real(conj(htilde).*received)./(abs(htilde).^2 * noise_var);
            decoded_bits = ldpcDecode(llr, decodercfg, 50);
            
            % Re-estimate channel using least squares
            hnought = received./(1-2*coded_bits);
            
        else
            % Uncoded transmission
            info_bits = randi([0 1], data_bits, 1);
            symbols = 1 - 2*info_bits;
            
            % Transmit through channel
            actual_channel = channel_values(current_idx:current_idx+data_bits-1);
            snr_db = EbNo_dB;
            SNR = 10^(snr_db/10);
            noise = sqrt(1/2) * (randn(data_bits,1) + 1j*randn(data_bits,1)) / sqrt(SNR);
            received = actual_channel.*symbols + noise;
            
            % Predict k channel values
            [Y, ~] = forecast(mdl, data_bits, channel_data);
            htilde = complex(Y(:,1), Y(:,2));
            
            % Demodulate using predicted channel
            decisions = real(received.*conj(htilde))./(abs(htilde).^2) < 0;
            
            % Re-estimate channel using least squares
            hnought = received./(1-2*decisions);
        end
        
        % Check MSE between predicted and estimated channel
        mse = mean(abs(htilde - hnought).^2);
        
        if mse > mse_threshold
            % Retransmit initial sequence
            info_bits = randi([0 1], initial_bits, 1);
            symbols = 1 - 2*info_bits;
            actual_channel = channel_values(current_idx:current_idx+initial_bits-1);
            noise = sqrt(1/2) * (randn(initial_bits,1) + 1j*randn(initial_bits,1)) / sqrt(SNR);
            received = actual_channel.*symbols + noise;
            channel_estimates = received./(1-2*info_bits);
            current_idx = current_idx + initial_bits;
            pilot_requests = pilot_requests + 1;
        else
            % Update estimates and continue
            channel_estimates = hnought;
            if use_coding
                current_idx = current_idx + n;
                wrong_bits = wrong_bits + sum(info_bits ~= decoded_bits(1:data_bits));
            else
                current_idx = current_idx + data_bits;
                wrong_bits = wrong_bits + sum(info_bits ~= decisions);
            end
            total_bits = total_bits + data_bits;
        end
    end
    
    retrans_freq = pilot_requests * initial_bits / total_bits;
    ber = wrong_bits / total_bits;
end

function [estimates, new_idx] = collectPilots(channel_values, current_idx, num_pilots, pilot_size)
    estimates = zeros(num_pilots, 1);
    for i = 1:num_pilots
        pilot_idx = current_idx + (i-1)*pilot_size;
        if pilot_idx + pilot_size > length(channel_values)
            break;
        end
        estimates(i) = mean(channel_values(pilot_idx:pilot_idx+pilot_size-1));
    end
    new_idx = current_idx + num_pilots*pilot_size;
end